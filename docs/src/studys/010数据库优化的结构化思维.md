> 关于数据库的优化可以从多个方面思考

- 设计层面
- SQL层面
## 一、设计层面
### 索引设计优化 

- 基于选择性来设计索引, 尽量在选择性高且常作为查找的列上建立索引(选择性 = 索引过滤数据/数据总量)
- 依据最左前缀索引原则建立合适的组合索引, 通过组合索引来实现部分覆盖查询
- 尽量不要在文本或者字符串(如UUID)之类的数据类型上建立索引, 这样会导致索引占用巨大, 导致同样的内存不能加载足够多的索引结构
- 尽量避免索引列存在空, 并且后续也应尽量避免通过 IS NULL/ IS NOT NULL 来进行索引列的查询
- 选取一些在where, join on , order by, group by等从句中高频使用的列建立索引
### 字段设计优化 	

- 枚举字段尽量用 tinyint/smallint而不是文本
- 主键尽量选用自增整形,这样有利于数据的连续性, 能够一定程度优化范围查找的顺序读
- Varchar 与 Char 按需求选择
- 字段长度尽量设计的按照实际来，不管是什么类型，哪怕是int, 预设过长会导致Mysql申请过多的内存
### 表划分设计优化 

- 避免宽表, 按需进行数据的冷热分离
- 在业务层面对数据大表进行垂直拆分, 提前规划好容量，如果无法提前预算容量，考虑按时间增长拆分
## 二、SQL层面
### 问题分析定位 

1. 通过慢查询日志定位出查询较慢的SQL, 执行一遍确认是真的执行很慢
2. 通过explain进行简单的分析：包括扫描行数, 索引使用情况等(通过范围类型type分析)
3. 确认是否真正需要访问这么多数据导致还是实际最终只需要一部却扫描了大量数据(索引失效)
### 对SQL本身的分析 

1. 是否存在查询返回了不需要的列, 是否存在 `select(*)` 之类的查询
2. 是否存在一些不适当的where条件使用导致索引失效 
   1. 组合索引未遵循最左前缀规则, 存在无最左，跳过，或者范围查询导致失效或者只生效了其中部分索引
   2. 是否在索引列上使用了函数或者用作计算了, 示例如下 
      1. 函数： select * from t where abs(id) = 2;
      2. 计算:  select * from t where id + 1 = 3;
   3. 是否存在null值判断
   4. 是否存在 like模糊匹配以 %开头
   5. or 语句前后是否都用上了索引?
   6. 是否存在数据隐式转换? Mysql会默认进行隐式转换, 转换成字段实际类型, 但是这个场景可能会导致索引失效, 如数字字符串如果不加 '' 则会导致失效
3. 是否存在过多的关联表查询, 过多的关联表查询会导致创建过大的虚拟币中间表，容易导致性能被拖垮
### 常用的一些优化方案 

- 按需要查询字段, 避免全列查询; 合理利用覆盖索引来减少回表查询, 尽量让SQL能够命中索引
- 关联查询优化, `ON` 或者 `USING` 条件列上确保有索引; 尽量将子查询优化为关联查询
- 尽量确保 `GROUP BY` 、 `ORDER BY` 只对单列进行操作, 这样才能使这些列命中上索引
- 针对大表的 limit 查询可以通过先查询主键然后基于主键范围或者 in 二次查询实现快速分页
## 
