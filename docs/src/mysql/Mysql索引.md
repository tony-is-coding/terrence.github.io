## 


### 从原理出发, 分析 「索引失效场景」

1、索引结构 是基于原始字段进行构建的, 所以当匹配字段不是原字段、类型不匹配场景都会导致索引实现
- 在索引列上使用 函数计算 会导致索引
- 索引列产生类型转换 / 隐式类型转换 会导致索引失效

2、索引的存储是有序的, 按照索引键默认排序, 这种排序有利于范围查询, 但是如果范围查询无法确定开始结束点, 则会导致无法合理使用查询
- 当使用 like 进行模糊查询的时候, 其实对于 Mysql 来说,也是范围查询的一种, 但是如果 like %xx查询,则会导致无法确定需要查找的字段索引范围, 也就无法使索引生效;
    - 最终可能选择全表扫描
 - 组合索引的存储也是按照索引定义顺序的 先后排序的 (A,B,C) 三列形成组合索引, 会先按照A排序, A相同情况下再按照B排序, 如果跳过A则会导致 索引无法正常生效
 

### B tree 和 B+ tree 的区别

从结构上来说,Btree、B+tree都是多路查找树, 两者最大的区别是在存储上
1. B tree会在每一个节点上存储索引的同时, 还存储下数据
2. B+tree只会在叶子节点进行数据存储, 根节点只存储节点索引数据和下一级节点的指针

优势: B+tree是在Btree基础上拓展来的，其优势主要体现在
1. B+tree 根节点不存储数据, 而MySQL在节点设计时, 综合考虑的操作系统的页大小和CPU缓存设计, 对每个节点的大小容量控制在单个系统页大小以下, 所以同样大小情况下, 每个B+Tree节点能够存储更多的子节点索引, 意味着每一层的扇出更大, 同样多的数据量情况下, B+tree往往拥有更低的树高
2. B+tree 叶子节点存储数据是连接的,因为索引设计本身是具备顺序的, 所以这样对于范围查找数据是更加有利的


 
 ### MVCC + next-key lock 
 1. 问: 什么是MVCC 机制?
 
    答： MVCC - 多版本并发控制机制是在 RR、RC隔离级别下生效的一种版本控制机制, 通过对数据进行快照版本存储, 实现数据的快照读/当前读等, 这样在多个事务并发情况下, 每个事务的数据互相隔离, 在未提交前都是基于备份的数据进行修改;
 MVCC的实现是在每个基于基础上增加了几个版本的概念, 来确保数据的版本隔离; 思想上是和 git 类似的
 
 
 2. 问 什么是next-key lock,  他的作用是?
    
    答: next-key lock 是 间隙锁 + 行锁的 组合,  对一个范围内的数据进行锁定，并锁定他们之间的间隙, 能够保证一个范围的查询在一个事务内的多次查询都是一样的结果 -- 即不存在幻读
        需要注意的是, next-key 是默认事务存在的 
        
 